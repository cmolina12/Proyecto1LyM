/*
Gramatica para el Robot:
Autor: Alejandro Arango
Modificado por: Silvia Takahashi
Modificado por: Juan Pablo Morales.
Agregadas producciones para manejar globos
Modificado por Silvia Takahashi
*/

options 
{
    LOOKAHEAD=3;  
    IGNORE_CASE=true;
    STATIC = false;
}

PARSER_BEGIN(Robot)

package uniandes.lym.robot.control;

import uniandes.lym.robot.kernel.*;
import uniandes.lym.robot.view.Console;
import java.awt.Point;
import java.io.*;
import java.util.Vector;
import java.util.LinkedList;
import java.util.HashMap;

@SuppressWarnings("serial")
public class Robot 
{
    private RobotWorldDec world;
    String salida = new String();

	private static HashMap<String, Integer > variables = new HashMap<String, Integer>();
	private static HashMap<String, Procedure > procedures = new HashMap < String, Procedure>();

	/* Metodos del Robot */

	public void setWorld (RobotWorld w) {
		world = (RobotWorldDec) w;
	  }

	// A√±adir una nueva variable
	public static void addVariable(Token token) {
		String image = token.image.toLowerCase();
		variables.put(image,0); // Inicializar la variable en 0

	}

	// A√±adir un nuevo procedimiento
	public static void addProcedure(Procedure procedure) {
		procedures.put(procedure.getName(), procedure);
	}
	

    // ‚úÖ **Asignar un valor a una variable**
    public static void assignVariable(Token variable, Token value) {
        String varName = variable.image.toLowerCase();
        String val = value.image.toLowerCase();
        
        if (variables.containsKey(varName)) {
            try {
                variables.put(varName, Integer.parseInt(val));  // üî• Convertimos a n√∫mero
            } catch (NumberFormatException e) {
                throw new Error("‚ùå No se puede asignar " + val + " a la variable " + varName);
            }
        } else {
            throw new Error("‚ùå La variable " + varName + " no est√° definida.");
        }
    }

	// Verificar si una variable existe
	public static void checkVariable(Token token) {
		String image = token.image.toLowerCase();
		if (!variables.containsKey(image)) {
			throw new Error("‚ùå La variable " + image + " no est√° definida. L√≠nea: " + token.beginLine);
		  }
	}

		// ‚úÖ Verifica si un procedimiento est√° definido
	public static void checkProcedure(Token token) {
	    String procName = token.image.toLowerCase();
	    if (!procedures.containsKey(procName)) {
	        throw new Error("‚ùå El procedimiento " + procName + " no est√° definido. L√≠nea: " + token.beginLine);
	    }
	}
	
	public static int number(String number) {
	    try {
	        return Integer.parseInt(number);
	    } catch (NumberFormatException ee) {
	        throw new Error("‚ùå No se puede convertir " + number + " a un n√∫mero.");
	    }
	}

	public static String convertDirection(String direction) {
	    switch (direction) {
	        case "front":
	            if (world.facingNorth()) {
	                direction = "north";
	            } else if (world.facingSouth()) {
	                direction = "south";
	            } else if (world.facingEast()) {
	                direction = "east";
	            } else {
	                direction = "west";
	            }
	            break;
	        case "back":
	            if (world.facingNorth()) {
	                direction = "south";
	            } else if (world.facingSouth()) {
	                direction = "north";
	            } else if (world.facingEast()) {
	                direction = "west";
	            } else {
	                direction = "east";
	            }
	            break;
	        case "right":
	            if (world.facingNorth()) {
	                direction = "east";
	            } else if (world.facingSouth()) {
	                direction = "west";
	            } else if (world.facingEast()) {
	                direction = "south";
	            } else {
	                direction = "north";
	            }
	            break;
	        case "left":
	            if (world.facingNorth()) {
	                direction = "west";
	            } else if (world.facingSouth()) {
	                direction = "east";
	            } else if (world.facingEast()) {
	                direction = "north";
	            } else {
	                direction = "south";
	            }
	            break;
	    }
	    return direction;
	}
	
	// Robot classes
	class Procedure {
	    private String name;
	    private ArrayList<String> params = new ArrayList<>();  // Lista de par√°metros
	    private ArrayList<Instruction> instructions = new ArrayList<>();  // Instrucciones del procedimiento
	    private HashMap<String, String> info = new HashMap<>();  // üîÑ Ahora usa String en lugar de Integer
	
	    public Procedure(String name) {
	        this.name = name.toLowerCase();
	    }
	
	    // ‚úÖ **Agregar un par√°metro al procedimiento**
	    public void addParam(String param) {
	        if (!Robot.variables.containsKey(param)) {
	            Robot.variables.put(param, 0);  // Inicializar el par√°metro en la tabla de variables globales
	        }
	        params.add(param);  // Guardarlo en la lista de par√°metros
	    }
	
	    // ‚úÖ **Agregar una instrucci√≥n al procedimiento**
	    public void addInstruction(Instruction instruction) {
	        instructions.add(instruction);
	    }
	
	    // ‚úÖ **Agregar un valor espec√≠fico a info**
	    public void addInfo(String key, String value) {
	        info.put(key, value);
	    }
	
	    // ‚úÖ **Ejecutar el procedimiento**
	    public void run() {
	        for (Instruction instruction : instructions) {
	            instruction.runFunction(info);  // ‚úÖ Pasamos `info` a cada instrucci√≥n como `String`
	        }
	    }
	
	    // ‚úÖ **Obtener el nombre del procedimiento**
	    public String getName() {
	        return name;
	    }
	
	    // ‚úÖ **Obtener los par√°metros del procedimiento**
	    public ArrayList<String> getParams() {
	        return params;
	    }
	
	    // ‚úÖ **Obtener el valor de un par√°metro en info**
		public String getParamValue(String param) {
		    if (info.containsKey(param)) {
		        return info.get(param);  // ‚úÖ Devolvemos el String sin convertirlo
		    } else {
		        throw new Error("‚ùå El par√°metro " + param + " no est√° definido en el procedimiento " + name);
		    }
		}




	



}

	
PARSER_END(Robot)

/**
 * Secci√≥n 1: Tokens del Robot
 */

SKIP : { " " | "\r" | "\t" | "\n" | "\f" }

/**
 * üîπ 1Ô∏è‚É£ Comandos del Robot 
 */
TOKEN : { <MOVE: "move"> }
TOKEN : { <TURN: "turn"> }
TOKEN : { <FACE: "face"> }
TOKEN : { <PICK: "pick"> }
TOKEN : { <PUT: "put"> }
TOKEN : { <JUMP: "jump"> }
TOKEN : { <GOTO: "goto"> }
TOKEN : { <NOP: "nop"> }

/**
 * üîπ 2Ô∏è‚É£ Direcciones y Orientaciones
 */
TOKEN : { <LEFT : "left"> }
TOKEN : { <RIGHT : "right"> }
TOKEN : { <AROUND : "around"> }
TOKEN : { <NORTH : "north"> }
TOKEN : { <SOUTH : "south"> }
TOKEN : { <WEST : "west"> }
TOKEN : { <EAST : "east"> }
TOKEN : { <FRONT : "front"> }
TOKEN : { <BACK : "back"> }
TOKEN : { <INDIR : "inDir"> }
TOKEN : { <TOTHE : "toThe"> }

/**
 * üîπ 3Ô∏è‚É£ Objetos en el Mundo del Robot 
 */
TOKEN : { <BALLOONS: "balloons"> }
TOKEN : { <CHIPS: "chips"> }

/**
 * üîπ 4Ô∏è‚É£ Estructuras de Control 
 */
TOKEN : { <IF: "if"> }
TOKEN : { <THEN: "then"> }
TOKEN : { <ELSE: "else"> }
TOKEN : { <WHILE: "while"> }
TOKEN : { <DO: "do"> }
TOKEN : { <REPEAT: "repeat"> }
TOKEN : { <FOR: "for"> }  // üî• AGREGADO

/**
 * üîπ 5Ô∏è‚É£ Condiciones
 */
TOKEN : { <FACING: "facing"> }
TOKEN : { <CANPUT: "canput"> }
TOKEN : { <CANPICK: "canpick"> }
TOKEN : { <CANMOVE: "canmove"> }
TOKEN : { <CANJUMP: "canjump"> }
TOKEN : { <NOT: "not"> }
TOKEN : { <OF_TYPE: "ofType"> }


/**
 * üîπ 6Ô∏è‚É£ S√≠mbolos y Operadores
 */
/**
 * üîπ 6Ô∏è‚É£ S√≠mbolos y Operadores
 */
TOKEN : { <LBRACKET: "["> }
TOKEN : { <RBRACKET: "]"> }
TOKEN : { <ASSIGN: ":="> }
TOKEN : { <END: "."> }
TOKEN : { <COMMA: ","> }
TOKEN : { <COLON: ":"> }
TOKEN : { <VARBLOCK: "|"> }
TOKEN : { <WITH: "with"> }  // ‚úÖ Agregado



/**
 * üîπ 7Ô∏è‚É£ Variables y Valores
 */
TOKEN : { <PROC : "proc"> }
TOKEN : { <AND : "and"> }
TOKEN : { <NAME : <LETTER> (<LETTER> | <DIGIT>)* > }
TOKEN : { <NUMBER : (<DIGIT>)+ > }
TOKEN : { <#LETTER : ["a"-"z", "A"-"Z"]> }
TOKEN : { <#DIGIT : ["0"-"9"]> }

/**
 * Secci√≥n 2: Reglas de Producci√≥n
 */

// üìå **Punto de inicio del parser**
boolean command(Console sistema) : { salida = new String(); Block block; }
{
    (VarDeclaration())?  // Variables opcionales
    (ProcDeclaration())* // Procedimientos opcionales
    block = Block()      // Bloque obligatorio
    <EOF> 
    { 
        block.run(); 
        variables.clear(); 
        procedures.clear(); 
        return false; 
    }
}

// üìå **Definir variables**
void VarDeclaration() :
{Token var;}
{
    <VARBLOCK> 
    var = <NAME> { variables.put(var.image, 0); }  // Primera variable obligatoria
    (var = <NAME> { variables.put(var.image, 0); })*  // Cualquier cantidad de variables adicionales
    <VARBLOCK>
}


/* Function Rules */

void ProcDeclaration() :
{
    Token procName;
}
{
    <PROC> (procName = <NAME> Block() { procedures.put(procName.image, ""); })+
}

void ProcedureDef() :
{
    Token procName, param;
    Procedure procedure;
    Block block;
}
{
    <PROC> procName = <NAME>  // Nombre del procedimiento
    { procedure = new Procedure(procName.image); }

    <COLON> param = <NAME> { procedure.addParam(param.image); }  // Ahora se guarda en `localVariables`

    // Se permiten m√°s par√°metros
    (<NAME> <COLON> param = <NAME> { procedure.addParam(param.image); })*

    block = Block()  // Cuerpo del procedimiento
    <END>  // Finaliza con `.`
    { procedure.setBlock(block); Robot.addProcedure(procedure); }
}





Instruction instruction() : {Instruction ins;} {
    ins = Command() { return ins; }
    | ins = ProcedureCall() { return ins; }
    | ins = ControlStructure() { return ins; }
    | ins = Assignment() { return ins; }  // üî• Agregamos la asignaci√≥n aqu√≠
}


// üìå **Definir los comandos**
void Command() :
{
    Token param1, param2, tag;
}
{
    (
		// ‚úÖ **Comando MOVE**
		<MOVE> <COLON> (param1 = <NUMBER> | param1 = <NAME> { Robot.checkVariable(param1); }) <END> {
		    world.moveForward(Integer.parseInt(param1.image), false); 
		}
		
		// ‚úÖ **Comando MOVE TO THE**
		| <MOVE> <COLON> (param1 = <NUMBER> | param1 = <NAME> { Robot.checkVariable(param1); }) 
		  <TOTHE> param2 = Direction() <END> {
		    world.moveForward(Integer.parseInt(param1.image), false);
		}
		
		// ‚úÖ **Comando MOVE IN DIR**
		| <MOVE> <COLON> (param1 = <NUMBER> | param1 = <NAME> { Robot.checkVariable(param1); }) 
		  <INDIR> param2 = Orientation() <END> {
		    world.moveForward(Integer.parseInt(param1.image), false);
		}


        // ‚úÖ **Comando JUMP**
        | <JUMP> <COLON> param1 = <NUMBER> <END> {
            world.moveForward(Integer.parseInt(param1.image), true);
        }

        // ‚úÖ **Comando JUMP TO THE**
        | <JUMP> <COLON> param1 = <NUMBER> <TOTHE> param2 = Direction() <END> {
            world.moveForward(Integer.parseInt(param1.image), true);
        }

        // ‚úÖ **Comando JUMP IN DIR**
        | <JUMP> <COLON> param1 = <NUMBER> <INDIR> param2 = Orientation() <END> {
            world.moveForward(Integer.parseInt(param1.image), true);
        }

        // ‚úÖ **Comando TURN**
        | <TURN> <COLON> param1 = Direction() <END> {
            if (param1.image.equals("right")) world.turnRight();
            else if (param1.image.equals("left")) world.turnLeft();
            else world.turnAround();
        }

        // ‚úÖ **Comando FACE**
        | <FACE> <COLON> param1 = Orientation() <END> {
            System.out.println("üëÄ Mirando hacia " + param1.image);
        }

        // ‚úÖ **Comando PUT**
        | <PUT> <COLON> (param1 = <NUMBER> | param1 = <NAME> { Robot.checkVariable(param1); }) <OF_TYPE> param2 = ObjectType() <END>
 {
            if (param2.image.equals("balloons")) {
                world.putBalloons(Integer.parseInt(param1.image));
            } else {
                world.putChips(Integer.parseInt(param1.image));
            }
        }

        // ‚úÖ **Comando PICK**
        | <PICK> <COLON> (param1 = <NUMBER> | param1 = <NAME> { Robot.checkVariable(param1); }) <OF_TYPE> param2 = ObjectType() <END>
 {
            if (param2.image.equals("balloons")) {
                world.grabBalloons(Integer.parseInt(param1.image));
            } else {
                world.pickChips(Integer.parseInt(param1.image));
            }
        }

        // ‚úÖ **Comando GOTO (modificado para aceptar variables)**
        | <GOTO> <COLON> (param1 = <NUMBER> | param1 = <NAME> { Robot.checkVariableF(param1); }) 
          <WITH> (param2 = <NUMBER> | param2 = <NAME> { Robot.checkVariableF(param2); }) <END> {
            world.setPostion(Integer.parseInt(param1.image), Integer.parseInt(param2.image));
        }

        // ‚úÖ **Comando NOP**
        | <NOP> <END> {
            System.out.println("‚è∏Ô∏è No hacer nada.");
        }
    )
}

ControlStructure ControlStructure() :
{
    Token str, var;
    Condition con;
    Block block1, block2;
}
{
    (
        // ‚úÖ **IF Statement**
        str = <IF> <COLON> con = Condition() <THEN> <COLON> 
        (block1 = Block() | block1 = OneInstruction()) 
        <ELSE> <COLON> 
        (block2 = Block() | block2 = OneInstruction()) 
        { return new ControlStructure(str, con, block1, block2); }

        // ‚úÖ **WHILE Loop**
        | str = <WHILE> <COLON> con = Condition() <DO> <COLON> 
        (block1 = Block() | block1 = OneInstruction())  
        { return new ControlStructure(str, con, block1); }

		// ‚úÖ **FOR Loop (for: n repeat:)**
		| str = <FOR> <COLON> (var = <NUMBER> | var = <NAME> { Robot.checkVariable(var); }) <REPEAT> 
		(block1 = Block() | block1 = OneInstruction())  
		{ return new ControlStructure(str, var, block1); }

    )
}

Condition Condition() : { Token con; Token param1; Token param2; Condition subcondition; } {
    (
        // ‚úÖ **Facing Condition** (Se deja como estaba antes)
        con = <FACING> <COLON> param1 = <NORTH> | param1 = <SOUTH> | param1 = <WEST> | param1 = <EAST>  
        { return new Condition(con, param1); }

		// ‚úÖ **CanPut & CanPick**
		| (con = <CANPUT> | con = <CANPICK>) <COLON> (param1 = <NUMBER> | param1 = <NAME> { Robot.checkVariable(param1); }) 
		  <OF_TYPE> (param2 = <BALLOONS> | param2 = <CHIPS>)  
		{ return new Condition(con, param1, param2); }
		
		// ‚úÖ **CanMove & CanJump (toThe)**
		| (con = <CANMOVE> | con = <CANJUMP>) <COLON> (param1 = <NUMBER> | param1 = <NAME> { Robot.checkVariable(param1); }) 
		  <TOTHE> (param2 = <FRONT> | param2 = <BACK> | param2 = <LEFT> | param2 = <RIGHT>)  
		{ return new Condition(con, param1, param2); }
		
		// ‚úÖ **CanMove & CanJump (inDir)**
		| (con = <CANMOVE> | con = <CANJUMP>) <COLON> (param1 = <NUMBER> | param1 = <NAME> { Robot.checkVariable(param1); }) 
		  <INDIR> (param2 = <NORTH> | param2 = <SOUTH> | param2 = <WEST> | param2 = <EAST>)  
		{ return new Condition(con, param1, param2); }


        // ‚úÖ **Not Condition**
        | con = <NOT> <COLON> subcondition = Condition()  
        { return new Condition(con, subcondition); }
    )
}


// üìå **Llamada a procedimientos con verificaci√≥n**
void ProcedureCall() :
{
    Token procName, param;
    ArrayList<Integer> values = new ArrayList<>();
}
{
    procName = <NAME>  

    {
        if (!procedures.containsKey(procName.image)) {
            throw new Error("‚ùå El procedimiento " + procName.image + " no est√° definido.");
        }
    }

    (<COLON> param = <NUMBER> | param = <NAME>  
        { 
            Robot.checkVariable(param);  
            values.add(Robot.getVariableValue(param.image));  // üî• Agrega el valor real del par√°metro
        }

        // Se permiten m√°s par√°metros
        (<NAME> <COLON> param = <NUMBER> | param = <NAME>  
            { 
                Robot.checkVariable(param);  
                values.add(Robot.getVariableValue(param.image));  
            }
        )*
    )?

    <END>  
    { procedures.get(procName.image).run(values); }  // üî• Ahora pasamos los valores correctos
}






Instruction Assignment() :
{
    Token var, value;
}
{
    var = <NAME> { Robot.checkVariable(var); } 
    <ASSIGN> (value = <NUMBER> | value = <NAME> { Robot.checkVariable(value); }) 
    <END>

    {
        if (Procedure.isExecuting()) {
            Procedure.getCurrentProcedure().setVariable(var.image, Robot.getVariableValue(value.image));
        } else {
            Robot.assignGlobalVariable(var, value);
        }
    }
}


// üìå **Bloque de instrucciones `[ ... ]`**
Block Block() : { Block block = new Block(); Instruction ins; } {
    <LBRACKET> 
    ins = instruction() { block.addInstruction(ins); }
    (<END> ins = instruction() { block.addInstruction(ins); })*  // üî• Separamos con `.`
    <RBRACKET>
    { return block; }
}

// üìå **Instrucci√≥n √∫nica (usada en IF, WHILE, etc.)**
Block OneInstruction() : { Block block = new Block(); Instruction ins; } {
    ins = instruction() { block.addInstruction(ins); }
    { return block; }
}

// üìå **Direcci√≥n del Robot**
Token Direction() : { Token param1; }
{
    ( param1 = <LEFT> | param1 = <RIGHT> | param1 = <AROUND> ) { return param1; }
}

// üìå **Orientaci√≥n del Robot**
Token Orientation() : { Token param1; }
{
    ( param1 = <NORTH> | param1 = <SOUTH> | param1 = <WEST> | param1 = <EAST> ) { return param1; }
}

// üìå **Tipo de Objeto (Globos, Fichas)**
Token ObjectType() : { Token param1; }
{
    ( param1 = <BALLOONS> | param1 = <CHIPS> ) { return param1; }
}




