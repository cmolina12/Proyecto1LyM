/*
Gramatica para el Robot:
Autor: Alejandro Arango
Modificado por: Silvia Takahashi
Modificado por: Juan Pablo Morales.
Agregadas producciones para manejar globos
Modificado por Silvia Takahashi
*/

options 
{
    LOOKAHEAD=3;  
    IGNORE_CASE=true;
    STATIC = false;
}

PARSER_BEGIN(Robot)

package uniandes.lym.robot.control;

import uniandes.lym.robot.kernel.*;
import uniandes.lym.robot.view.Console;
import java.awt.Point;
import java.io.*;
import java.util.Vector;
import java.util.LinkedList;
import java.util.HashMap;
import java.util.ArrayList;

@SuppressWarnings("serial")
public class Robot 
{
    private static RobotWorldDec world;
    String salida = new String();

	private static HashMap<String, String > variables = new HashMap<String, String>();
	private static HashMap<String, Procedure > procedures = new HashMap < String, Procedure>();

	/* Metodos del Robot */

	public void setWorld (RobotWorld w) {
		world = (RobotWorldDec) w;
	  }

	// A√±adir una nueva variable
	public static void addVariable(Token token) {
		String image = token.image.toLowerCase();
		variables.put(image,"0"); // Inicializar la variable en null

	}

	// A√±adir un nuevo procedimiento
	public static void addProcedure(Procedure procedure) {
		procedures.put(procedure.getName(), procedure);
	}
	

	// ‚úÖ **Asignar un valor a una variable**
	public static void assignVariable(String number, String variable) {
	    if (variables.containsKey(variable)) {
	        variables.put(variable, number);  // üî• Ahora guarda el n√∫mero como String
	    } else {
	        throw new Error("‚ùå No se puede asignar " + number + " a la variable " + variable + " porque no est√° definida.");
	    }
	}



	// Verificar si una variable existe
	public static void checkVariable(Token token) {
		String image = token.image.toLowerCase();
		if (!variables.containsKey(image)) {
			throw new Error("‚ùå La variable " + image + " no est√° definida. L√≠nea: " + token.beginLine);
		  }
	}

		// ‚úÖ Verifica si un procedimiento est√° definido
	public static void checkProcedure(Token token) {
	    String procName = token.image.toLowerCase();
	    if (!procedures.containsKey(procName)) {
	        throw new Error("‚ùå El procedimiento " + procName + " no est√° definido. L√≠nea: " + token.beginLine);
	    }
	}

	public static Procedure getProcedure(Token token) {
	    String procName = token.image.toLowerCase();
	    if (procedures.containsKey(procName)) {
	        return procedures.get(procName);
	    } else {
	        throw new Error("‚ùå El procedimiento " + procName + " no est√° definido. L√≠nea: " + token.beginLine);
	    }
	}

	
	public static int number(String number) {
	    try {
	        return Integer.parseInt(number);
	    } catch (NumberFormatException ee) {
	        throw new Error("‚ùå No se puede convertir " + number + " a un n√∫mero.");
	    }
	}

	public static String convertDirection(String direction) {
	    switch (direction) {
	        case "front":
	            if (world.facingNorth()) {
	                direction = "north";
	            } else if (world.facingSouth()) {
	                direction = "south";
	            } else if (world.facingEast()) {
	                direction = "east";
	            } else {
	                direction = "west";
	            }
	            break;
	        case "back":
	            if (world.facingNorth()) {
	                direction = "south";
	            } else if (world.facingSouth()) {
	                direction = "north";
	            } else if (world.facingEast()) {
	                direction = "west";
	            } else {
	                direction = "east";
	            }
	            break;
	        case "right":
	            if (world.facingNorth()) {
	                direction = "east";
	            } else if (world.facingSouth()) {
	                direction = "west";
	            } else if (world.facingEast()) {
	                direction = "south";
	            } else {
	                direction = "north";
	            }
	            break;
	        case "left":
	            if (world.facingNorth()) {
	                direction = "west";
	            } else if (world.facingSouth()) {
	                direction = "east";
	            } else if (world.facingEast()) {
	                direction = "north";
	            } else {
	                direction = "south";
	            }
	            break;
	    }
	    return direction;
	}
	
	// Robot classes
	class Procedure {
	    private String name;
	    private ArrayList<String> params = new ArrayList<>();  // Lista de par√°metros
	    private ArrayList<Instruction> instructions = new ArrayList<Instruction>();  // Instrucciones del procedimiento
	    private HashMap<String, String> info = new HashMap<>();  // üîÑ Ahora usa String en lugar de Integer
		private Block block;
		
	    public Procedure(String name) {
	        this.name = name.toLowerCase();
	    }

	    public void setBlock(Block block) {  // üî• M√©todo que faltaba
	        this.block = block;
	    }
	
	    // ‚úÖ **Agregar un par√°metro al procedimiento**
	    public void addParam(String param) {
	        if (!Robot.variables.containsKey(param)) {
	            Robot.variables.put(param, "0");  // Inicializar el par√°metro en la tabla de variables globales
	        }
	        params.add(param);  // Guardarlo en la lista de par√°metros
	    }
	
	    // ‚úÖ **Agregar una instrucci√≥n al procedimiento**
	    public void addInstruction(Instruction instruction) {
	        instructions.add(instruction);
	    }
	
	    // ‚úÖ **Agregar un valor espec√≠fico a info**
	    public void addInfo(String key, String value) {
	        info.put(key, value);
	    }
	
	    // ‚úÖ **Obtener el nombre del procedimiento**
	    public String getName() {
	        return name;
	    }
	
	    // ‚úÖ **Obtener los par√°metros del procedimiento**
	    public ArrayList<String> getParams() {
	        return params;
	    }
	
	    // ‚úÖ **Obtener el valor de un par√°metro en info**
		public String getParamValue(String param) {
		    if (info.containsKey(param)) {
		        return info.get(param);  // ‚úÖ Devolvemos el String sin convertirlo
		    } else {
		        throw new Error("‚ùå El par√°metro " + param + " no est√° definido en el procedimiento " + name);
		    }
		}

	    // ‚úÖ **Ejecutar el procedimiento**
	    public void run() {
	        for (Instruction instruction : instructions) {
	            instruction.runFunction(info);  // ‚úÖ Pasamos `info` a cada instrucci√≥n como `String`
	        }
	    }
	

		public void runFunction(HashMap<String, String> info) {
			for (Instruction instruction: instructions) {
			instruction.runFunction(info);
			 }
		 }
	}
	class Block{

		private ArrayList<Instruction> instructions = new ArrayList<>();

		public void addInstruction(Instruction instruction) {
			instructions.add(instruction);



		}

		public void run(){
			for (Instruction instruction : instructions) {
				instruction.run();
			}



		}

		public void runFunction(HashMap<String, String> info) {
			for (Instruction instruction : instructions) {
				instruction.runFunction(info);
			}
		}
	}

	abstract class Instruction {
			public abstract void run();
			public abstract void runFunction(HashMap<String, String> info);
		}

			// Constructores
	class Command extends Instruction {
	    private String com;
	    private String var1;
	    private String var2;
	    private int x;
	    private int y;
	    private int endOrientation;
	    private boolean r = true;
	    private HashMap<String, Integer> hm = new HashMap<String, Integer>() {{
	        put("#north", 0);
	        put("#east", 1);
	        put("#south", 2);
	        put("#west", 3);
	    }};
 		private String moveType;
	
	    // Constructores
	    public Command(Token com, Token var1, Token var2) {
	        this.com = com.image.toLowerCase();
	        this.var1 = var1.image.toLowerCase();
	        this.var2 = var2.image.toLowerCase();
	    }
	
	    public Command(Token com, Token var1) {
	        this.com = com.image.toLowerCase();
	        this.var1 = var1.image.toLowerCase();
	    }
	
	    public Command(Token com) {
	        this.com = com.image.toLowerCase();
	    }

		public Command(Token com, Token param1, Token param2, String moveType) {
		    this.com = com.image.toLowerCase();
		    this.var1 = param1.image.toLowerCase();
		    this.var2 = (param2 != null) ? param2.image.toLowerCase() : null;
		    this.moveType = moveType;
		
		    // ‚úÖ Si es `jump`, lo tratamos diferente internamente
		    if (com.image.equalsIgnoreCase("jump")) {
		        this.moveType = moveType.replace("move", "jump");  // Convierte "moveToThe" en "jumpToThe"
		    }
		}


	
	    public void face(int endOrientation) {
	        int initialOrientation = world.getFacing();
	        int nOfRightTurns = numberOfRightTurns(initialOrientation, endOrientation);
	        for (int i = 0; i < nOfRightTurns; i++) {
	            world.turnRight();
	        }
	    }
	
	    public int numberOfRightTurns(int initialOrientation, int endOrientation) {
	        int nOfRightTurns = 0;
	        if (initialOrientation != endOrientation) {
	            if ((initialOrientation + endOrientation) % 4 == 1)
	                nOfRightTurns = 2;
	            else if ((initialOrientation + endOrientation) == 3) {
	                if (initialOrientation > endOrientation) {
	                    nOfRightTurns = 1;
	                } else {
	                    nOfRightTurns = 3;
	                }
	            } else if (initialOrientation < endOrientation) {
	                nOfRightTurns = 1;
	            } else if (initialOrientation > endOrientation) {
	                nOfRightTurns = 3;
	            }
	        }
	        return nOfRightTurns;
	    }
	
		public void run() {
		    verify();
		
		    System.out.println("üöÄ Ejecutando " + com + " con param1=" + var1 + 
		                      (var2 != null ? " y param2=" + var2 : ""));
		
		    switch (com) {
		        // ‚úÖ Asignaci√≥n de variables `:=`
		        case ":=":
		            Robot.assignVariable(var1, var2);
		            break;
		
		        // ‚úÖ Comando `goto: x with: y .`
		        case "goto":
		            x = number(var1);
		            y = number(var2);
		            if (!world.isBlocked(new Point(x, y))) {
		                world.setPostion(x, y);
		            } else {
		                throw new Error("Cannot move to " + x + ", " + y + " because that position is blocked");
		            }
		            break;
		
		        // ‚úÖ Comandos `move: n .` y `jump: n .`
		        case "move":
		        case "jump":
		            x = number(var1);
		
		            if (var2 != null) {
		                if (moveType.equals("toThe")) {
		                    var2 = Robot.convertDirection(var2);
		                }
		                if (moveType.equals("inDir")) {
		                    endOrientation = hm.get(var2);
		                    face(endOrientation);
		                }
		            }
		
		            // üî• Si es `move`, se mueve normalmente. Si es `jump`, salta.
		            boolean isJump = com.equals("jump");
		            System.out.println("‚û°Ô∏è " + (isJump ? "Saltando" : "Moviendo") + " " + x + " pasos en modo " + moveType);
		            world.moveForward(x, isJump);
		            break;
		
		        // ‚úÖ Comando `turn: D .`
		        case "turn":
		            if (var1.equals("#right")) {
		                world.turnRight();
		            } else if (var1.equals("#around")) {
		                world.turnRight();
		                world.turnRight();
		            } else if (var1.equals("#left")) {
		                world.turnRight();
		                world.turnRight();
		                world.turnRight();
		            }
		            break;
		
		        // ‚úÖ Comando `face: O .`
		        case "face":
		            if (hm.containsKey(var1)) {
		                endOrientation = hm.get(var1);
		                face(endOrientation);
		            } else {
		                throw new Error("Invalid orientation in 'face:' command");
		            }
		            break;
		
		        // ‚úÖ Comando `put: n ofType: X .`
		        case "put":
		            if (var2 != null) {
		                x = number(var1);
		                if (var2.equals("#chips")) {
		                    world.putChips(x);
		                } else if (var2.equals("#balloons")) {
		                    world.putBalloons(x);
		                } else {
		                    throw new Error("Invalid object type in 'put:' command");
		                }
		            } else {
		                throw new Error("Object type missing in 'put:' command");
		            }
		            break;
		
		        // ‚úÖ Comando `pick: n ofType: X .`
		        case "pick":
		            if (var2 != null) {
		                x = number(var1);
		                if (var2.equals("#chips")) {
		                    world.pickChips(x);
		                } else if (var2.equals("#balloons")) {
		                    world.grabBalloons(x);
		                } else {
		                    throw new Error("Invalid object type in 'pick:' command");
		                }
		            } else {
		                throw new Error("Object type missing in 'pick:' command");
		            }
		            break;
		
		        // ‚úÖ Comando `nop .`
		        case "nop":
		            System.out.println("‚è∏Ô∏è No hacer nada.");
		            break;
		
		        default:
		            throw new Error("‚ùå Comando desconocido: " + com);
		    }
		}


		public void runFunction(HashMap<String, String> info) {
		    verifyF(info);
		
		    System.out.println("üöÄ Ejecutando " + com + " con param1=" + var1 + 
		                      (var2 != null ? " y param2=" + var2 : ""));
		
		    switch (com) {
		        // ‚úÖ Asignaci√≥n de variables `:=`
		        case ":=":
		            Robot.assignVariable(var1, var2);
		            break;
		
		        // ‚úÖ Comando `goto: x with: y .`
		        case "goto":
		            x = number(var1);
		            y = number(var2);
		            if (!world.isBlocked(new Point(x, y))) {
		                world.setPostion(x, y);
		            } else {
		                throw new Error("Cannot move to " + x + ", " + y + " because that position is blocked");
		            }
		            break;
		
		        // ‚úÖ Comandos `move: n .` y `jump: n .`
		        case "move":
		        case "jump":
		            x = number(var1);
		
		            if (var2 != null) {
		                if (moveType.equals("toThe")) {
		                    var2 = Robot.convertDirection(var2);
		                }
		                if (moveType.equals("inDir")) {
		                    endOrientation = hm.get(var2);
		                    face(endOrientation);
		                }
		            }
		
		            boolean isJump = com.equals("jump");
		            System.out.println("‚û°Ô∏è " + (isJump ? "Saltando" : "Moviendo") + " " + x + " pasos en modo " + moveType);
		            world.moveForward(x, isJump);
		            break;
		
		        // ‚úÖ Comando `turn: D .`
		        case "turn":
		            if (var1.equals("#right")) {
		                world.turnRight();
		            } else if (var1.equals("#around")) {
		                world.turnRight();
		                world.turnRight();
		            } else if (var1.equals("#left")) {
		                world.turnRight();
		                world.turnRight();
		                world.turnRight();
		            }
		            break;
		
		        // ‚úÖ Comando `face: O .`
		        case "face":
		            if (hm.containsKey(var1)) {
		                endOrientation = hm.get(var1);
		                face(endOrientation);
		            } else {
		                throw new Error("Invalid orientation in 'face:' command");
		            }
		            break;
		
		        // ‚úÖ Comando `put: n ofType: X .`
		        case "put":
		            if (var2 != null) {
		                x = number(var1);
		                if (var2.equals("#chips")) {
		                    world.putChips(x);
		                } else if (var2.equals("#balloons")) {
		                    world.putBalloons(x);
		                } else {
		                    throw new Error("Invalid object type in 'put:' command");
		                }
		            } else {
		                throw new Error("Object type missing in 'put:' command");
		            }
		            break;
		
		        // ‚úÖ Comando `pick: n ofType: X .`
		        case "pick":
		            if (var2 != null) {
		                x = number(var1);
		                if (var2.equals("#chips")) {
		                    world.pickChips(x);
		                } else if (var2.equals("#balloons")) {
		                    world.grabBalloons(x);
		                } else {
		                    throw new Error("Invalid object type in 'pick:' command");
		                }
		            } else {
		                throw new Error("Object type missing in 'pick:' command");
		            }
		            break;
		
		        // ‚úÖ Comando `nop .`
		        case "nop":
		            System.out.println("‚è∏Ô∏è No hacer nada.");
		            break;
		
		        default:
		            throw new Error("‚ùå Comando desconocido: " + com);
		    }
		}

		// üìå ‚úÖ Verificaci√≥n en ejecuci√≥n normal (no confunde n√∫meros con variables)
		public void verify() {
		    if (!isNumber(var1) && (!Robot.variables.containsKey(var1) || Robot.variables.get(var1) == null)) {
		        throw new Error("‚ùå Variable no definida: " + var1);
		    }
		    if (var2 != null && !isNumber(var2) && (!Robot.variables.containsKey(var2) || Robot.variables.get(var2) == null)) {
		        throw new Error("‚ùå Variable no definida: " + var2);
		    }
		}

		// üìå ‚úÖ Verificaci√≥n en ejecuci√≥n de funci√≥n (maneja variables y n√∫meros correctamente)
		public void verifyF(HashMap<String, String> info) {
		    if (!isNumber(var1)) {
		        if (info.containsKey(var1) && info.get(var1) != null) {
		            var1 = info.get(var1);
		        } else if (Robot.variables.containsKey(var1) && Robot.variables.get(var1) != null) {
		            var1 = Robot.variables.get(var1);
		        } else {
		            throw new Error("‚ùå Variable no definida: " + var1);
		        }
		    }
		
		    if (var2 != null && !isNumber(var2)) {
		        if (info.containsKey(var2) && info.get(var2) != null) {
		            var2 = info.get(var2);
		        } else if (Robot.variables.containsKey(var2) && Robot.variables.get(var2) != null) {
		            var2 = Robot.variables.get(var2);
		        } else {
		            throw new Error("‚ùå Variable no definida: " + var2);
		        }
		    }
		}
		
		// üìå ‚úÖ M√©todo auxiliar para verificar si un string es un n√∫mero
		private boolean isNumber(String str) {
		    try {
		        Integer.parseInt(str);
		        return true;
		    } catch (NumberFormatException e) {
		        return false;
		    }
		}


	}

			
	
	


	class ProcedureCall extends Instruction {
		private Token name;
		private Procedure procedure;
		private ArrayList<String> params;
		private ArrayList<String> values = new ArrayList<>();
	
		public ProcedureCall(Token name) {
			this.name = name;
			this.procedure = Robot.getProcedure(name);  // Cambiamos Function ‚Üí Procedure
			this.params = procedure.getParams();
		}
	
		public void addValue(Token name) {
			String image = name.image.toLowerCase();
			values.add(image);
		}
	
		public void run() {
			execute();
		}
	
		public void runFunction(HashMap<String, String> info) {
			execute(info);
		}
	
		private void execute() {
			if (values.size() != params.size()) {
				throw new Error("The procedure " + name.image.toLowerCase() + 
								" must have " + params.size() + " params, not " + values.size() +
								"\nLine: " + name.beginLine);
			}
	
			// Mapeamos valores pasados a los par√°metros del procedimiento
			HashMap<String, String> localInfo = new HashMap<>();
			for (int i = 0; i < values.size(); i++) {
				localInfo.put(params.get(i), values.get(i));
			}
	
			// Ejecutamos el procedimiento con los valores correctos
			procedure.runFunction(localInfo);
		}
	
		private void execute(HashMap<String, String> parentInfo) {
			if (values.size() != params.size()) {
				throw new Error("The procedure " + name.image.toLowerCase() + 
								" must have " + params.size() + " params, not " + values.size() +
								"\nLine: " + name.beginLine);
			}
	
			// Mapeamos valores con la informaci√≥n de `parentInfo`
			HashMap<String, String> localInfo = new HashMap<>();
			for (int i = 0; i < values.size(); i++) {
				String param = params.get(i);
				String value = values.get(i);
	
				// Si el valor est√° en `parentInfo`, lo usamos
				if (parentInfo.containsKey(value)) {
					value = parentInfo.get(value);
				}
				localInfo.put(param, value);
			}
	
			// Ejecutamos el procedimiento con los valores correctos
			procedure.runFunction(localInfo);
		}
	}

	class ControlStructure extends Instruction {
		private String str;
		private Condition con;
		private String var;
		private Block block1;
		private Block block2;
	
		// Constructor para if-else
		public ControlStructure(Token str, Condition con, Block block1, Block block2){
			this.str = str.image.toLowerCase();
			this.con = con;
			this.block1 = block1;
			this.block2 = block2;
		}
	
		// Constructor para while
		public ControlStructure(Token str, Condition con, Block block1){
			this.str = str.image.toLowerCase();
			this.con = con;
			this.block1 = block1;
		}
	
		// Constructor para for
		public ControlStructure(Token str, Token var, Block block1){
			this.str = str.image.toLowerCase();
			this.var = var.image.toLowerCase();  
			if (Robot.variables.containsKey(this.var)) {
				this.var = String.valueOf(Robot.variables.get(this.var));  // Convertir a n√∫mero
			} else {
				throw new Error("‚ùå Variable no definida: " + this.var);
			}
			this.block1 = block1;
		}
	
		@Override
		public void run() {
		  switch (str) {
			case "if":
				if (con.run()) {block1.run();} 
				else {block2.run();}
				break;
			case "while":
				  while(con.run()) { 
					block1.run();
				}
				break;
			case "for":  // üî• Cambio de repeat ‚Üí for
				verify();
				for (int i = 0;  i < Integer.parseInt(var);  i++) {
					block1.run();
				}
				break;
			}
		}
	
		@Override
		public void runFunction(HashMap<String, String> info) {
		  switch (str) {
			case "if":
				if (con.runFunction(info)) {
					block1.runFunction(info);
				} else {
					block2.runFunction(info);
				}
				break;
			case "while":
				  while(con.runFunction(info)) { 
					block1.runFunction(info);
				}
				break;
			case "for":  // üî• Cambio de repeat ‚Üí for
				verifyF(info);
				String value = info.containsKey(var) ? info.get(var) : var;
				for (int i = 0;  i < Integer.parseInt(value);  i++) {
					block1.runFunction(info);
				}
				break;
			}
		}
	
		// ‚úÖ Verificaci√≥n de variables en ejecuci√≥n normal
		public void verify() {
			if  (Robot.variables.containsKey(var) && Robot.variables.get(var) != null) {
				var = String.valueOf(Robot.variables.get(var));
			} else {
				throw new Error("‚ùå Variable no definida: " + var);
			}
		}
	
		// ‚úÖ Verificaci√≥n de variables en ejecuci√≥n de funci√≥n
		public void verifyF(HashMap<String, String> info) {
			  if (info.containsKey(var) && info.get(var) != null) {
				var = info.get(var);
			} else if  (Robot.variables.containsKey(var) && Robot.variables.get(var) != null) {
				var = String.valueOf(Robot.variables.get(var));
			} else {
				throw new Error("‚ùå Variable no definida: " + var);
			}
		}
	}
	
	class Condition {
		private String con;
		private String var1;
		private String var2;
		private Condition subcondition;
		private int x;
		private boolean r = false;
	
		// Constructores
		public Condition(Token con, Token var1, Token var2){
			this.con = con.image.toLowerCase();
			this.var1 = var1.image.toLowerCase();
			this.var2 = var2.image.toLowerCase();
		}
	
		public Condition(Token con, Token var1){
			this.con = con.image.toLowerCase();
			this.var1 = var1.image.toLowerCase();
		}
	
		public Condition(Token con, Condition subcondition){
			this.con = con.image.toLowerCase();
			this.subcondition = subcondition;
		}
	
		// ‚úÖ M√©todo para verificar si puede moverse en una direcci√≥n espec√≠fica
		public boolean canMove() {
			r = true;
			x = Robot.number(var1);  
			Point point = world.getPosition();
			Point change = new Point(point);
	
			switch (var2) {
				case "north":
					for(int i = 0; i < x; i++) {
						change.translate(0, -1);
						if (r) { r = !world.isBlocked(change); }
					}
					break;
				case "south":
					for(int i = 0; i < x; i++) {
						change.translate(0, 1);
						if (r) { r = !world.isBlocked(change); }
					}
					break;
				case "east":
					for(int i = 0; i < x; i++) {
						change.translate(1, 0);
						if (r) { r = !world.isBlocked(change); }
					}
					break;
				case "west":
					for(int i = 0; i < x; i++) {
						change.translate(-1, 0);
						if (r) { r = !world.isBlocked(change); }
					}
					break;
			}
			return r;
		}
	
		// ‚úÖ M√©todo para verificar si puede saltar en una direcci√≥n espec√≠fica
		public boolean canJump() {
			r = true;
			x = Robot.number(var1);
			Point point = world.getPosition();
			Point change = new Point(point);
	
			switch (var2) {
				case "north":
					change.translate(0, -x);
					break;
				case "south":
					change.translate(0, x);
					break;
				case "east":
					change.translate(x, 0);
					break;
				case "west":
					change.translate(-x, 0);
					break;
			}
			r = !world.isBlocked(change);
			return r;
		}
	
		public boolean run() {
		    verify();
		    
		
		    switch (con) {
		        case "facing":
		            switch (var1) {
		                case "north": r = world.facingNorth(); break;
		                case "south": r = world.facingSouth(); break;
		                case "east":  r = world.facingEast();  break;
		                case "west":  r = world.facingWest();  break;
		            }
		            break;
		        case "canput":
		            x = Robot.number(var1);
		            r = var2.equals("chips") ? world.freeSpacesForChips() >= x : !world.chipExists();
		            break;
		        case "canpick":
		            x = Robot.number(var1);
		            r = var2.equals("chips") ? world.chipsToPick() >= x : world.countBalloons() >= x;
		            break;
		        case "canmove":
		        case "canjump":
		            if (var2.equals("north") || var2.equals("south") || var2.equals("east") || var2.equals("west")) {
		                // Caso `inDir: O` (orientaci√≥n fija)
		                r = con.equals("canmove") ? canMove() : canJump();
		            } else {
		                // Caso `toThe: D` (direcci√≥n relativa ‚Üí convertimos a cardinal)
		                var2 = Robot.convertDirection(var2);
		                r = con.equals("canmove") ? canMove() : canJump();
		            }
		            break;
		        case "not":
		            r = !subcondition.run();
		            break;
		    }
		    return r;
		}

	
		public boolean runFunction(HashMap<String, String> info) {
			verifyF(info);
	
			boolean r = false;
			switch(con) {
				case "facing":
					switch (var1) {
						case "north": r = world.facingNorth(); break;
						case "south": r = world.facingSouth(); break;
						case "east":  r = world.facingEast();  break;
						case "west":  r = world.facingWest();  break;
					}
					break;
				case "canput":
					x = Robot.number(var1);
					r = var2.equals("chips") ? world.freeSpacesForChips() >= x : !world.chipExists();
					break;
				case "canpick":
					x = Robot.number(var1);
					r = var2.equals("chips") ? world.chipsToPick() >= x : world.countBalloons() >= x;
					break;
				case "canmove":
					r = canMove();
					break;
				case "canjump":
					r = canJump();
					break;
				case "canmovetothe":
					var2 = Robot.convertDirection(var2);
					r = canMove();
					break;
				case "canjumptothe":
					var2 = Robot.convertDirection(var2);
					r = canJump();
					break;                    
				case "not":
					r = !subcondition.runFunction(info);
					break;
			}
			return r;
		}
	
		// ‚úÖ Verificaci√≥n en ejecuci√≥n normal
		public void verify() {
		    if (Robot.variables.containsKey(var1) && Robot.variables.get(var1) != null) {
		        var1 = String.valueOf(Robot.variables.get(var1));
		    }
		    if (Robot.variables.containsKey(var2) && Robot.variables.get(var2) != null) {
		        var2 = String.valueOf(Robot.variables.get(var2));
		    } else {
		        // Si `var2` es una direcci√≥n relativa, la convertimos a cardinal
		        var2 = Robot.convertDirection(var2);
		    }
		}

	
		// ‚úÖ Verificaci√≥n en ejecuci√≥n de funci√≥n
		public void verifyF(HashMap<String, String> info) {
			if (info.containsKey(var1) && info.get(var1) != null) {
				var1 = info.get(var1);
			} else if (Robot.variables.containsKey(var1) && Robot.variables.get(var1) != null) {
				var1 = String.valueOf(Robot.variables.get(var1));
			}
	
			if (info.containsKey(var2) && info.get(var2) != null) {
				var2 = info.get(var2);
			} else if (Robot.variables.containsKey(var2) && Robot.variables.get(var2) != null) {
				var2 = String.valueOf(Robot.variables.get(var2));
			}
		}

	}

}
	
PARSER_END(Robot)

/**
 * Secci√≥n 1: Tokens del Robot
 */

SKIP : { " " | "\r" | "\t" | "\n" | "\f" }

/**
 * üîπ 1Ô∏è‚É£ Comandos del Robot 
 */
TOKEN : { <MOVE: "move"> }
TOKEN : { <TURN: "turn"> }
TOKEN : { <FACE: "face"> }
TOKEN : { <PICK: "pick"> }
TOKEN : { <PUT: "put"> }
TOKEN : { <JUMP: "jump"> }
TOKEN : { <GOTO: "goto"> }
TOKEN : { <NOP: "nop"> }

/**
 * üîπ 2Ô∏è‚É£ Direcciones y Orientaciones
 */
TOKEN : { <LEFT : "left"> }
TOKEN : { <RIGHT : "right"> }
TOKEN : { <AROUND : "around"> }
TOKEN : { <NORTH : "north"> }
TOKEN : { <SOUTH : "south"> }
TOKEN : { <WEST : "west"> }
TOKEN : { <EAST : "east"> }
TOKEN : { <FRONT : "front"> }
TOKEN : { <BACK : "back"> }
TOKEN : { <INDIR : "inDir"> }
TOKEN : { <TOTHE : "toThe"> }

/**
 * üîπ 3Ô∏è‚É£ Objetos en el Mundo del Robot 
 */
TOKEN : { <BALLOONS: "balloons"> }
TOKEN : { <CHIPS: "chips"> }

/**
 * üîπ 4Ô∏è‚É£ Estructuras de Control 
 */
TOKEN : { <IF: "if"> }
TOKEN : { <THEN: "then"> }
TOKEN : { <ELSE: "else"> }
TOKEN : { <WHILE: "while"> }
TOKEN : { <DO: "do"> }
TOKEN : { <REPEAT: "repeat"> }
TOKEN : { <FOR: "for"> }  // üî• AGREGADO

/**
 * üîπ 5Ô∏è‚É£ Condiciones
 */
TOKEN : { <FACING: "facing"> }
TOKEN : { <CANPUT: "canput"> }
TOKEN : { <CANPICK: "canpick"> }
TOKEN : { <CANMOVE: "canmove"> }
TOKEN : { <CANJUMP: "canjump"> }
TOKEN : { <NOT: "not"> }
TOKEN : { <OF_TYPE: "ofType"> }


/**
 * üîπ 6Ô∏è‚É£ S√≠mbolos y Operadores
 */
/**
 * üîπ 6Ô∏è‚É£ S√≠mbolos y Operadores
 */
TOKEN : { <LBRACKET: "["> }
TOKEN : { <RBRACKET: "]"> }
TOKEN : { <ASSIGN: ":="> }
TOKEN : { <END: "."> }
TOKEN : { <COMMA: ","> }
TOKEN : { <COLON: ":"> }
TOKEN : { <VARBLOCK: "|"> }
TOKEN : { <WITH: "with"> }  // ‚úÖ Agregado



/**
 * üîπ 7Ô∏è‚É£ Variables y Valores
 */
TOKEN : { <PROC : "proc"> }
TOKEN : { <AND : "and"> }
TOKEN : { <NAME : <LETTER> (<LETTER> | <DIGIT>)* > }
TOKEN : { <NUMBER : (<DIGIT>)+ > }
TOKEN : { <#LETTER : ["a"-"z", "A"-"Z"]> }
TOKEN : { <#DIGIT : ["0"-"9"]> }

/**
 * Secci√≥n 2: Reglas de Producci√≥n
 */

boolean command(Console sistema) : { 
    salida = new String(); 
    Block block = null;  
    Instruction ins = null;  
}
{
    (VarDeclaration())?  // Variables opcionales
    (ProcDeclaration())* // Procedimientos opcionales
    (
        block = Block() 
        | ins = instruction() // ‚úÖ Asegurar que `instruction()` se pueda llamar correctamente
    )  
    <EOF> 
    { 
        if (block != null) {  
            System.out.println("‚úÖ Se ejecutar√° un bloque de instrucciones");
            block.run();
        } else if (ins != null) {  
            System.out.println("‚úÖ Se ejecutar√° una sola instrucci√≥n");
            ins.run();
        } else {
            System.out.println("‚ùå ERROR: No se reconoci√≥ ninguna instrucci√≥n");
        }
        variables.clear(); 
        procedures.clear(); 
        return false; 
    }
}











// üìå **Definir variables**
void VarDeclaration() :
{Token var;}
{
    <VARBLOCK> 
    var = <NAME> { 
        Robot.addVariable(var);  
        System.out.println("üü¢ Se ha declarado la variable: " + var.image);
    }  
    (var = <NAME> { 
        Robot.addVariable(var);
        System.out.println("üü¢ Se ha declarado la variable: " + var.image);
    })*  
    <VARBLOCK> 
    { System.out.println("‚úÖ Fin de VarDeclaration()"); }
}





/* Function Rules */

void ProcDeclaration() :
{
    Token procName;
    Procedure procedure;
}
{
    <PROC> procName = <NAME>
    { procedure = new Procedure(procName.image); }  // ‚úÖ Creamos la instancia correcta

    Block()  // ‚úÖ Se asume que el bloque contiene las instrucciones
    { Robot.addProcedure(procedure); }  // ‚úÖ Se guarda en `procedures`
}


void ProcedureDef() :
{
    Token procName, param;
    Procedure procedure;
    Block block;
}
{
    <PROC> procName = <NAME>  // Nombre del procedimiento
    { procedure = new Procedure(procName.image); }

    <COLON> param = <NAME> { procedure.addParam(param.image); }  // Ahora se guarda en `localVariables`

    // Se permiten m√°s par√°metros
    (<NAME> <COLON> param = <NAME> { procedure.addParam(param.image); })*

    block = Block()  // Cuerpo del procedimiento
    <END>  // Finaliza con `.`
    { procedure.setBlock(block); Robot.addProcedure(procedure); }
}





Instruction instruction() : { Instruction ins; } {
    { System.out.println("üü¢ Intentando reconocer una instrucci√≥n..."); }  // ‚úÖ Print de depuraci√≥n

    ins = Move() { System.out.println("üü¢ Se reconoci√≥ MOVE"); return ins; } 
    | ins = Jump() { System.out.println("üü¢ Se reconoci√≥ JUMP"); return ins; }  
    | ins = Command() { System.out.println("üü¢ Se reconoci√≥ un Command"); return ins; }
    | ins = ProcedureCall() { System.out.println("üü¢ Se reconoci√≥ una llamada a procedimiento"); return ins; }
    | ins = ControlStructure() { System.out.println("üü¢ Se reconoci√≥ una estructura de control"); return ins; }
}






// üìå **Definir los comandos**
Command Command() :
{
    Token com, param1, param2;
}
{
    (

        // ‚úÖ **Comando ASSIGN (asignaci√≥n `:=`)**
        com = <ASSIGN> param1 = <NAME> { Robot.checkVariable(param1); } 
        <COLON> (param2 = <NUMBER> | param2 = <NAME> { Robot.checkVariable(param2); }) <END> 
        { return new Command(com, param1, param2); }


        // ‚úÖ **Comando TURN**
        | com = <TURN> <COLON> param1 = Direction() <END> {
            return new Command(com, param1);
        }

        // ‚úÖ **Comando FACE**
        | com = <FACE> <COLON> param1 = Orientation() <END> {
            return new Command(com, param1);
        }

        // ‚úÖ **Comando PUT**
        | com = <PUT> <COLON> (param1 = <NUMBER> | param1 = <NAME> { Robot.checkVariable(param1); }) 
          <OF_TYPE> param2 = ObjectType() <END> {
            return new Command(com, param1, param2);
        }

        // ‚úÖ **Comando PICK**
        | com = <PICK> <COLON> (param1 = <NUMBER> | param1 = <NAME> { Robot.checkVariable(param1); }) 
          <OF_TYPE> param2 = ObjectType() <END> {
            return new Command(com, param1, param2);
        }

        // ‚úÖ **Comando GOTO**
        | com = <GOTO> <COLON> (param1 = <NUMBER> | param1 = <NAME> { Robot.checkVariable(param1); }) 
          <WITH> (param2 = <NUMBER> | param2 = <NAME> { Robot.checkVariable(param2); }) <END> {
            return new Command(com, param1, param2);
        }

        // ‚úÖ **Comando NOP**
        | com = <NOP> <END> {
            return new Command(com);
        }
    )
}


ControlStructure ControlStructure() :
{
    Token str, var;
    Condition con;
    Block block1, block2;
}
{
    (
        // ‚úÖ **IF Statement**
        str = <IF> <COLON> con = Condition() <THEN> <COLON> 
        (block1 = Block() | block1 = OneInstruction()) 
        <ELSE> <COLON> 
        (block2 = Block() | block2 = OneInstruction()) 
        { return new ControlStructure(str, con, block1, block2); }

        // ‚úÖ **WHILE Loop**
        | str = <WHILE> <COLON> con = Condition() <DO> <COLON> 
        (block1 = Block() | block1 = OneInstruction())  
        { return new ControlStructure(str, con, block1); }

		// ‚úÖ **FOR Loop (for: n repeat:)**
		| str = <FOR> <COLON> (var = <NUMBER> | var = <NAME> { Robot.checkVariable(var); }) <REPEAT> 
		(block1 = Block() | block1 = OneInstruction())  
		{ return new ControlStructure(str, var, block1); }

    )
}

Condition Condition() : { Token con = null; Token param1; Token param2; Condition subcondition; } {
    (
        con = <FACING> <COLON> param1 = <NORTH> | param1 = <SOUTH> | param1 = <WEST> | param1 = <EAST>  
        { return new Condition(con, param1); }

        | (con = <CANPUT> | con = <CANPICK>) <COLON> 
          (param1 = <NUMBER> | param1 = <NAME> { Robot.checkVariable(param1); }) 
          <OF_TYPE> (param2 = <BALLOONS> | param2 = <CHIPS>)  
        { return new Condition(con, param1, param2); }

        | (con = <CANMOVE> | con = <CANJUMP>) <COLON> 
          (param1 = <NUMBER> | param1 = <NAME> { Robot.checkVariable(param1); }) 
          ( <TOTHE> (param2 = <FRONT> | param2 = <BACK> | param2 = <LEFT> | param2 = <RIGHT>)  
          | <INDIR> (param2 = <NORTH> | param2 = <SOUTH> | param2 = <WEST> | param2 = <EAST>) )  
        { return new Condition(con, param1, param2); }

        | con = <NOT> <COLON> subcondition = Condition()  
        { return new Condition(con, subcondition); } 
    )
}




// üìå **Llamada a procedimientos con verificaci√≥n**
ProcedureCall ProcedureCall() :
{
    Token procName, param;
    ProcedureCall call;
}
{
    procName = <NAME> <COLON> { call = new ProcedureCall(procName); }

    ((param = <NUMBER> | param = <NAME> { Robot.checkVariable(param); }) { call.addValue(param); }
    
    (<COMMA> (param = <NUMBER> | param = <NAME> { Robot.checkVariable(param); }) { call.addValue(param); })*)?

    <END> { return call; }  // üî• Importante: ahora devolvemos el objeto `ProcedureCall`
}

// üìå **Bloque de instrucciones `[ ... ]`**
Block Block() : { Block block = new Block(); Instruction ins; } {
    <LBRACKET> 
    ins = instruction() { block.addInstruction(ins); }
    (<END> ins = instruction() { block.addInstruction(ins); })*  // üî• Separamos con `.`
    <RBRACKET>
    { return block; }
}

// üìå **Instrucci√≥n √∫nica (usada en IF, WHILE, etc.)**
Block OneInstruction() : { Block block = new Block(); Instruction ins; } {
    ins = instruction() { block.addInstruction(ins); }
    { return block; }
}

// üìå **Direcci√≥n del Robot**
Token Direction() : { Token param; }
{
    param = <FRONT> { return param; }
    | param = <BACK> { return param; }
    | param = <LEFT> { return param; }
    | param = <RIGHT> { return param; }
}

// üìå **Orientaci√≥n del Robot**
Token Orientation() : { Token param; }
{
    param = <NORTH> { return param; }
    | param = <SOUTH> { return param; }
    | param = <WEST> { return param; }
    | param = <EAST> { return param; }
}

// üìå **Tipo de Objeto (Globos, Fichas)**
Token ObjectType() : { Token param1; }
{
    ( param1 = <BALLOONS> | param1 = <CHIPS> ) { return param1; }
}

Command Move() :
{
    Token com, param1, param2 = null;
    String moveType = "simple";  // Puede ser "simple", "toThe", o "inDir"
}
{
    com = <MOVE> <COLON> 
    ( param1 = <NUMBER> | param1 = <NAME> { Robot.checkVariable(param1); } ) 
    (
        <TOTHE> param2 = Direction() { moveType = "toThe"; }
        | <INDIR> param2 = Orientation() { moveType = "inDir"; }
    )? 
    <END>
    {
        System.out.println("üü¢ Parser: Se cre√≥ un comando MOVE " + moveType + 
                          " con param1=" + param1.image + 
                          (param2 != null ? " y param2=" + param2.image : ""));
        return new Command(com, param1, param2, moveType);
    }

}

Command Jump() :
{
    Token com, param1, param2 = null;
    String jumpType = "simple";  // Puede ser "simple", "toThe", o "inDir"
}
{
    com = <JUMP> <COLON> 
    ( param1 = <NUMBER> | param1 = <NAME> { Robot.checkVariable(param1); } ) 
    (
        <TOTHE> param2 = Direction() { jumpType = "toThe"; }
        | <INDIR> param2 = Orientation() { jumpType = "inDir"; }
    )? 
    <END>
    {
        System.out.println("üü¢ Parser: Se cre√≥ un comando JUMP " + jumpType + 
                          " con param1=" + param1.image + 
                          (param2 != null ? " y param2=" + param2.image : ""));
        return new Command(com, param1, param2, jumpType);
    }
}







